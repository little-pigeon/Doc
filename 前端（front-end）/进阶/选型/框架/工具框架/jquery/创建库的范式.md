## 创建库的范式
# 范式一 (init，extend，可以不使用)
```js
;(
	function(global, factory){
		"use strict";
		// 兼容处理
		if ( typeof module === "object" && typeof module.exports === "object" ) {
			module.exports = global.document ?
				factory( global, true ) :
				function( w ) {
					if ( !w.document ) {
						throw new Error( "jQuery requires a window with a document" );
					}
					return factory( w );
				};
		} else {
			factory( global );
		}
	}
)(
	typeof window !== "undefined" ? window : this,
	function( window, noGlobal ){
		"use strict";
		var jQuery;

		// 为什么要加个fn属性
		// 1、核心方法可以保持纯净
		// 2、不受第三方扩展的污染和影响
		hi.fn = jQuery.prototype = {}

		// 为什么定义一个init变量
		// 1、init可以包含所有，除了hi的私有属性
		// 2、init.prototype = hi.fn = hi.fn.prototype + hi.fn的属性和方法 = hi.prototype
		// 那么 init类 》 hi.fn类 》 hi类
		var init = hi.fn.init = function() {}
		init.prototype = hi.fn

		// 巧妙
		// 1、hi.extend增强hi类的扩展性
		// 2、hi.fn.extend增强hi类实例的扩展性
		// 3、统一了添加方法的方式，
		// $.** => $是一个构造函数，静态调用函数
		// $().** => $()是一个实例，该实例带有$所有的方法，非静态（即实例）调用函数
		// $()得到的实例，肯定不是new jQuery()
		jQuery.extend = jQuery.fn.extend = function() {
			var options, name, src, copy, copyIsArray, clone,
				target = arguments[ 0 ] || {},
				i = 1,
				length = arguments.length,
				deep = false;

			// Handle a deep copy situation
			if ( typeof target === "boolean" ) {
				deep = target;

				// Skip the boolean and the target
				target = arguments[ i ] || {};
				i++;
			}

			// Handle case when target is a string or something (possible in deep copy)
			if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
				target = {};
			}

			// Extend jQuery itself if only one argument is passed
			if ( i === length ) {
				target = this;
				i--;
			}

			for ( ; i < length; i++ ) {

				// Only deal with non-null/undefined values
				if ( ( options = arguments[ i ] ) != null ) {

					// Extend the base object
					for ( name in options ) {
						src = target[ name ];
						copy = options[ name ];

						// Prevent never-ending loop
						if ( target === copy ) {
							continue;
						}

						// Recurse if we're merging plain objects or arrays
						if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
							( copyIsArray = Array.isArray( copy ) ) ) ) {

							if ( copyIsArray ) {
								copyIsArray = false;
								clone = src && Array.isArray( src ) ? src : [];

							} else {
								clone = src && jQuery.isPlainObject( src ) ? src : {};
							}

							// Never move original objects, clone them
							target[ name ] = jQuery.extend( deep, clone, copy );

						// Don't bring in undefined values
						} else if ( copy !== undefined ) {
							target[ name ] = copy;
						}
					}
				}
			}

			// Return the modified object
			return target;
		}
		/* 栗子
		jQuery.fn.extend({
			a: 1,
			b: 'hello'
		})
		*/

		// 定义私有属性，实例不能使用
		jQuery.isArray = Array.isArray;

		// 作为amd模块输出
		if ( typeof define === "function" && define.amd ) {
			define( "jquery", [], function() {
				return jQuery;
			} );
		}

		// 巧妙的设置
		// 和第三方库共用$变量时，可以释放$的控制权，避免冲突
		// 使用的时候，也就只能用jQuery，而不能用$
		var _jQuery = window.jQuery,
 			_$ = window.$;

		jQuery.noConflict = function( deep ) {
			if ( window.$ === jQuery ) {
				window.$ = _$;
			}

			if ( deep && window.jQuery === jQuery ) {
				window.jQuery = _jQuery;
			}

			return jQuery;
		};

		// 暴露jQuery对象
		if ( !noGlobal ) {
			window.jQuery = window.$ = jQuery;
		}

		return jQuery;
	}
)
```

# 范式二（缺憾：兼容性差，限制于window对象为顶层对象的环境中）
```js
;(function(){
	"use strict";

	var jQuery;
	window.jQuery = jQuery;
})()
```